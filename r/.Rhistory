inds <- matrix(NA,nrow=numiters-1,ncol=n)
for (i in 2:numiters){
## sampling indicator variables
I <- rep(NA,n)
for (j in 1:n){
a <- dnorm(Y[j],mu1,sqrt(sigsq1))*alpha
b <- dnorm(Y[j],mu0,sqrt(sigsq0))*(1-alpha)
p <- a/(a+b)
I[j] <- rbinom(1,1,p)
}
## calculating statistics from indicator variables
n0 <- sum(I==0)
n1 <- sum(I==1)
meanY0 <- mean(Y[I==0])
meanY1 <- mean(Y[I==1])
## sampling alphas
alpha <- rbeta(1,n1+1,n0+1)
## sampling means
mu0 <- rnorm(1,meanY0,sqrt(sigsq0/n0))
mu1 <- rnorm(1,meanY1,sqrt(sigsq1/n1))
## calculating statistics from new means
ss0 <- sum((Y[I==0]-mu0)^2)
ss1 <- sum((Y[I==1]-mu1)^2)
## sampling variances
temp <- rgamma(1,shape=(n0/2)+1,rate=ss0/2)
sigsq0 <- 1/temp
temp <- rgamma(1,shape=(n1/2)+1,rate=ss1/2)
sigsq1 <- 1/temp
## storing current values
params[i,] <- c(alpha,mu0,mu1,sigsq0,sigsq1)
inds[i-1,] <- I
print(i)
print(round(c(alpha,mu0,mu1,sigsq0,sigsq1),5))
}
params.chain1 <- params
#alternate starting point
alpha <- 0.80
mu0 <- 0.03
mu1 <- 0.05
sigsq0 <- 0.005
sigsq1 <- 0.005
#running Gibbs sampler for alternate starting point with code above
params.chain2 <- params
par(mfrow=c(3,2))
ymin <- min(params.chain1[,1],params.chain2[,1])
ymax <- max(params.chain1[,1],params.chain2[,1])
plot(1:numiters,params.chain1[,1],main="alpha",type="l",col=2,ylim=c(ymin,ymax))
lines(1:numiters,params.chain2[,1],col=3)
ymin <- min(params.chain1[,2],params.chain2[,2])
ymax <- max(params.chain1[,2],params.chain2[,2])
plot(1:numiters,params.chain1[,2],main="mu0",type="l",col=2,ylim=c(ymin,ymax))
lines(1:numiters,params.chain2[,2],col=3)
ymin <- min(params.chain1[,3],params.chain2[,3])
ymax <- max(params.chain1[,3],params.chain2[,3])
plot(1:numiters,params.chain1[,3],main="mu1",type="l",col=2,ylim=c(ymin,ymax))
lines(1:numiters,params.chain2[,3],col=3)
ymin <- min(params.chain1[,4],params.chain2[,4])
ymax <- max(params.chain1[,4],params.chain2[,4])
plot(1:numiters,params.chain1[,4],main="sigsq0",type="l",col=2,ylim=c(ymin,ymax))
lines(1:numiters,params.chain2[,4],col=3)
ymin <- min(params.chain1[,5],params.chain2[,5])
ymax <- max(params.chain1[,5],params.chain2[,5])
plot(1:numiters,params.chain1[,5],main="sigsq1",type="l",col=2,ylim=c(ymin,ymax))
lines(1:numiters,params.chain2[,5],col=3)
params.chain1.postburn<-params.chain1[201:2000,]
params.chain2.postburn<-params.chain2[201:2000,]
par(mfrow=c(5,2))
acf(params.chain1.postburn[,1],lag.max=100,main="ACF: alpha, chain 1")
par(mfrow=c(5,2))
acf(params.chain1.postburn[,1],lag.max=100,main="ACF: alpha, chain 1")
acf(params.chain2.postburn[,1],lag.max=100,main="ACF: alpha, chain 2")
acf(params.chain1.postburn[,2],lag.max=100,main="ACF: mu0, chain 1")
acf(params.chain2.postburn[,2],lag.max=100,main="ACF: mu0, chain 2")
acf(params.chain1.postburn[,3],lag.max=100,main="ACF: mu1, chain 1")
acf(params.chain2.postburn[,3],lag.max=100,main="ACF: mu1, chain 2")
acf(params.chain1.postburn[,4],lag.max=100,main="ACF: sigsq0, chain 1")
acf(params.chain2.postburn[,4],lag.max=100,main="ACF: sigsq0, chain 2")
acf(params.chain1.postburn[,5],lag.max=100,main="ACF: sigsq1, chain 1")
acf(params.chain2.postburn[,5],lag.max=100,main="ACF: sigsq1, chain 2")
# taking only every fiftieth draw
temp <- 50*c(1:(1800/50))
params.chain1.thinned <- params.chain1.postburn[temp,]
params.chain2.thinned <- params.chain2.postburn[temp,]
par(mfrow=c(5,2))
acf(params.chain1.thinned[,1],lag.max=100,main="ACF: alpha, chain 1")
acf(params.chain2.thinned[,1],lag.max=100,main="ACF: alpha, chain 2")
acf(params.chain1.thinned[,2],lag.max=100,main="ACF: mu0, chain 1")
acf(params.chain2.thinned[,2],lag.max=100,main="ACF: mu0, chain 2")
acf(params.chain1.thinned[,3],lag.max=100,main="ACF: mu1, chain 1")
acf(params.chain2.thinned[,3],lag.max=100,main="ACF: mu1, chain 2")
acf(params.chain1.thinned[,4],lag.max=100,main="ACF: sigsq0, chain 1")
acf(params.chain2.thinned[,4],lag.max=100,main="ACF: sigsq0, chain 2")
acf(params.chain1.thinned[,5],lag.max=100,main="ACF: sigsq1, chain 1")
acf(params.chain2.thinned[,5],lag.max=100,main="ACF: sigsq1, chain 2")
# combining chains and calculating posterior intervals
params.final <- rbind(params.chain1.thinned,params.chain2.thinned)
numsamples <- length(params.final[,1])
alpha.gibbs <- params.final[,1]
mu0.gibbs <- params.final[,2]
mu1.gibbs <- params.final[,3]
sigsq0.gibbs <- params.final[,4]
sigsq1.gibbs <- params.final[,5]
par(mfrow=c(3,2))
hist(mu0.gibbs,col="gray")
abline(v=mu0.EM,col="red",lwd=2)
hist(mu1.gibbs,col="gray")
abline(v=mu1.EM,col="red",lwd=2)
hist(sigsq0.gibbs,col="gray")
abline(v=sigsq0.EM,col="red",lwd=2)
hist(sigsq1.gibbs,col="gray")
abline(v=sigsq1.EM,col="red",lwd=2)
hist(alpha.gibbs,col="gray")
abline(v=alpha.EM,col="red",lwd=2)
par(mfrow=c(1,1))
hist(hrprop,main="Home Run Proportions",xlab="y",col="gray")
numY <- length(Y)
xpoints <-ppoints(1000)*0.15
for (i in 1:numsamples){
ylines <- 100*(alpha.gibbs[i]*dnorm(xpoints,mu1.gibbs[i],sqrt(sigsq1.gibbs[i])) + (1-alpha.gibbs[i])*dnorm(xpoints,mu0.gibbs[i],sqrt(sigsq0.gibbs[i])))
lines(xpoints,ylines,col="red")
}
y.EM <- 100*((1-alpha.EM)*dnorm(xpoints,mu0.EM,sqrt(sigsq0.EM)) + alpha.EM*dnorm(xpoints,mu1.EM,sqrt(sigsq1.EM)))
lines(x,y.EM,col=1,lwd=2)
#reading in data:
data1 <- read.table("../data/91.seq")
numseq <- length(data1[,1])
#transforming data into sequence matrix:
seqmat <- NULL
for (i in 1:numseq){
seqarray <- strsplit(as.character(data1[i,1]),split="")
seqmat <- rbind(seqmat,seqarray[[1]])
}
numpos <- length(seqmat[1,])
numpos
S <- matrix(NA,nrow=numseq,ncol=numpos)
for (i in 1:numseq){
for (j in 1:numpos){
if (seqmat[i,j] == "a"){S[i,j] <- 1}
if (seqmat[i,j] == "c"){S[i,j] <- 2}
if (seqmat[i,j] == "g"){S[i,j] <- 3}
if (seqmat[i,j] == "t"){S[i,j] <- 4}
}
}
data1[1,]
seqmat[1,]
S[1,]
# motif width
w <- 12
# counting total number of nucleotides in data
N <- rep(NA,4)
for (k in 1:4){
N[k] <- sum(S==k)
}
N
w
head(data1)
head(seqmat)
head(S)
seqmat[91,]
seqmat[,91]
dim(seq)
dim(seqmat)
#reading in data:
data1 <- read.table("../data/91.seq")
numseq <- length(data1[,1])
#transforming data into sequence matrix:
seqmat <- NULL
for (i in 1:numseq){
seqarray <- strsplit(as.character(data1[i,1]),split="")
seqmat <- rbind(seqmat,seqarray[[1]])
}
numpos <- length(seqmat[1,])
S <- matrix(NA,nrow=numseq,ncol=numpos)
for (i in 1:numseq){
for (j in 1:numpos){
if (seqmat[i,j] == "a"){S[i,j] <- 1}
if (seqmat[i,j] == "c"){S[i,j] <- 2}
if (seqmat[i,j] == "g"){S[i,j] <- 3}
if (seqmat[i,j] == "t"){S[i,j] <- 4}
}
}
data1[1,]
seqmat[1,]
S[1,]
head(data1)
head(seqmat)
head(S)
# motif width
w <- 12
# counting total number of nucleotides in data
N <- rep(NA,4)
for (k in 1:4){
N[k] <- sum(S==k)
}
N
head(S)
dim(S)
N
data1[1,]
sample.a <- function(seq,theta,theta0){
numvalid <- numpos - w + 1
# calculating probs at each position
probs <- rep(NA,numvalid)
for (pos in 1:numvalid){
curseq <- seq[pos:(pos+w-1)]
probs[pos] <- 1
for (j in 1:w){
curnuc <- curseq[j]
probs[pos] <- probs[pos]*(theta[j,curnuc]/theta0[curnuc])
}
}
# normalizing probs
probs <- probs/sum(probs)
# sampling new location
new.a <- sample(1:numvalid,1,prob=probs)
new.a
}
# function for counting motif nucleotides
count.motif <- function(A){
N.motif <- matrix(0,nrow=w,ncol=4)
for (i in 1:numseq){
start <- A[i]
for (j in 1:w){
pos <- start + j - 1
curnuc <- S[i,pos]
N.motif[j,curnuc] <- N.motif[j,curnuc] + 1
#print(c(i,j,pos,curnuc))
}
}
N.motif
}
# function for counting background nucleotides
count.background <- function(N.motif){
N.back <- N  # starting with all nucleotides
for (k in 1:4){
temp <- sum(N.motif[,k])
N.back[k] <- N.back[k] - temp
}
N.back
}
# function for sampling new motif frequencies
sample.theta <- function(N.motif){
theta <- matrix(NA,nrow=w,ncol=4)
for (j in 1:w){
for (k in 1:4){
theta[j,k] <- rgamma(1,N.motif[j,k]+0.1,1)
}
theta[j,] <- theta[j,]/sum(theta[j,])
}
theta
}
sample.theta0 <- function(N.back){
theta0 <- rep(NA,4)
for (k in 1:4){
theta0[k] <- rgamma(1,N.back[k]+0.1,1)
}
theta0 <- theta0/sum(theta0)
theta0
}
# Gibbs sampler
numiters <- 100
A.iters <- matrix(NA,nrow=numiters,ncol=numseq)
A <- sample(1:88,size=numseq)
A.iters[1,] <- A
for (n in 2:numiters){
curmotif <- count.motif(A)
curback <- count.background(curmotif)
curtheta <- sample.theta(curmotif)
curtheta0 <- sample.theta0(curback)
for (i in 1:numseq){
A[i] <- sample.a(S[i,],curtheta,curtheta0)
}
A.iters[n,] <- A
print (n)
}
A.iters[,1]
A.iters[,2]
# printing out current motif sites
A.final <- A.iters[numiters,]
sitesmat <- matrix(NA,nrow=20,ncol=2)
for (i in 1:20){
cursite <- NULL
cursitepos <- A.final[i]
for (j in 1:w){
cursite <- paste(cursite,seqmat[i,cursitepos+j-1],sep="")
}
sitesmat[i,1] <- cursitepos
sitesmat[i,2] <- cursite
}
sitesmat
cursite
data2 <- read.table("../data/85.seq")
numseq <- length(data2[,1])
seqmat <- NULL
for (i in 1:numseq){
seqarray <- strsplit(as.character(data2[i,1]),split="")
seqmat <- rbind(seqmat,seqarray[[1]])
}
numpos <- length(seqmat[1,])
S <- matrix(NA,nrow=numseq,ncol=numpos)
for (i in 1:numseq){
for (j in 1:numpos){
if (seqmat[i,j] == "a"){S[i,j] <- 1}
if (seqmat[i,j] == "c"){S[i,j] <- 2}
if (seqmat[i,j] == "g"){S[i,j] <- 3}
if (seqmat[i,j] == "t"){S[i,j] <- 4}
}
}
w <- 12
N <- rep(NA,4)
for (k in 1:4){
N[k] <- sum(S==k)
}
A.iters[,1]
A.iters[,2]
# printing out current motif sites
A.final <- A.iters[numiters,]
sitesmat <- matrix(NA,nrow=20,ncol=2)
for (i in 1:20){
cursite <- NULL
cursitepos <- A.final[i]
for (j in 1:w){
cursite <- paste(cursite,seqmat[i,cursitepos+j-1],sep="")
}
sitesmat[i,1] <- cursitepos
sitesmat[i,2] <- cursite
}
sitesmat
###########################################################
##### Different dataset (even less clear signal) ##########
###########################################################
data3 <- read.table("../data/70.seq")
numseq <- length(data3[,1])
seqmat <- NULL
for (i in 1:numseq){
seqarray <- strsplit(as.character(data3[i,1]),split="")
seqmat <- rbind(seqmat,seqarray[[1]])
}
numpos <- length(seqmat[1,])
S <- matrix(NA,nrow=numseq,ncol=numpos)
for (i in 1:numseq){
for (j in 1:numpos){
if (seqmat[i,j] == "a"){S[i,j] <- 1}
if (seqmat[i,j] == "c"){S[i,j] <- 2}
if (seqmat[i,j] == "g"){S[i,j] <- 3}
if (seqmat[i,j] == "t"){S[i,j] <- 4}
}
}
w <- 12
N <- rep(NA,4)
for (k in 1:4){
N[k] <- sum(S==k)
}
setwd(old_wd)
pass_age_diff_draws
## by position, fit age curves
pass_age_diff_draws[, age_floor := floor(age)]
pass_age_diff_draws
stats_summary <- pass_age_diff_draws[, .(mean_b = mean(b, na.rm = TRUE),
sd_b = sd(b, na.rm = TRUE),
mean_b_yoy_diff = mean(b_yoy_diff, na.rm = TRUE),
sd_b_yoy_diff = sd(b_yoy_diff, na.rm = TRUE)),
.by = (age_floor, ngs_position)]
# Calculate mean and standard deviation
stats_summary <- pass_age_diff_draws[, .(mean_b = mean(b, na.rm = TRUE),
sd_b = sd(b, na.rm = TRUE),
mean_b_yoy_diff = mean(b_yoy_diff, na.rm = TRUE),
sd_b_yoy_diff = sd(b_yoy_diff, na.rm = TRUE)),
.by = .(age_floor, ngs_position)]
calc_quantiles <- function(x) {
as.list(quantile(x, probs = seq(0.01, 0.99, by = 0.01), na.rm = TRUE))
}
# Calculate mean, standard deviation, and quantiles, grouped by 'age_floor' and 'ngs_position'
summary_stats <- pass_age_diff_draws[, .(mean_b = mean(b, na.rm = TRUE),
sd_b = sd(b, na.rm = TRUE),
quantiles_b = calc_quantiles(b),
mean_b_yoy_diff = mean(b_yoy_diff, na.rm = TRUE),
sd_b_yoy_diff = sd(b_yoy_diff, na.rm = TRUE),
quantiles_b_yoy_diff = calc_quantiles(b_yoy_diff)),
by = .(age_floor, ngs_position)]
summary_stats
nlevels(summary_stats$ngs_position)
count(nlevels(summary_stats$ngs_position))
count(summary_stats$ngs_position)
table(summary_stats$ngs_position)
length(table(summary_stats$ngs_position))
length(rep(default_quantile_seq, times = length(table(summary_stats$ngs_position)) ))
# Calculate mean and standard deviation
default_quantile_seq <- seq(0.01, 0.99, by = 0.01)
length(rep(default_quantile_seq, times = length(table(summary_stats$ngs_position)) ))
summary_stats[,
quantile := default_quantile_seq,
.by = .(age_floor, ngs_position)]
summary_stats[,
quantile := default_quantile_seq,
by = .(age_floor, ngs_position)]
summary_stats
pass_summary_stats = pass_summary_stats
pass_summary_stats = summary_stats
rm(summary_stats)
rm(player_draws_pass)
gc(verbose = TRUE)
pass_summary_stats <- as.data.frame(pass_summary_stats) %>% as_tibble()
pass_summary_stats
pass_summary_stats %>% unnest(cols = starts_with("quantiles"))
pass_summary_stats <- as.data.frame(pass_summary_stats) %>%
as_tibble() %>%
unnest(cols = starts_with("quantiles"))
pass_summary_stats %>%
ggplot(aes(x = age_floor,
y = quantiles_b_yoy_diff,
group = quantile)) +
geom_line() +
theme_bw() +
facet_wrap(~ngs_position)
## plot age curve
pass_summary_stats %>%
ggplot(aes(x = age_floor,
y = quantiles_b_yoy_diff,
group = quantile,
col = quantile)) +
geom_line(alpha = 0.5) +
theme_bw() +
theme(legend.position = 'bottom') +
facet_wrap(~ngs_position)
play_type
objects_to_read
object_name_read
summary_stats %>%
mutate(play_type = play_type_run)
play_type_run
play_type_run ='pass'
final_age_summary <- NULL
for(object_name in objects_to_read){
object_name_read <- paste0(object_name, "_", play_type_run, ".parquet")
temp <- aws.s3::s3read_using(x = get(object_name),
FUN = arrow::read_parquet,
bucket = bucket_name,
object = paste0(file_path, object_name_read)
)
assign(str_remove(str_remove(object_name_read, "_pass|_rush"), ".parquet"), temp)
}
# create tibble with one row per player season. --------
## combine player_tbl_play_type_rush & player_tbl_play_type_pass
player_play_type_season_df <- player_tbl_play_type %>%
dplyr::select(
draft_number,
gsis_id,
entry_year:contract_apy_cap_pct
) %>%
mutate(play_type = play_type_run) %>%
distinct() %>%
arrange(gsis_id,
play_type) %>%
slice(rep(1:n(), times = tot_seasons)) %>%
mutate(start_season = coalesce(start_season, min(start_season, na.rm = TRUE) ),
end_season = coalesce(end_season, max(end_season, na.rm = TRUE) )
) %>%
group_by(gsis_id,
play_type) %>%
mutate(season_index = 1:n(),
season = (start_season - 1) + season_index ) %>%
ungroup()
#replace missing birthdates with average age for non-missing birthdays for their first season
avg_rookie_age <- player_play_type_season_df %>%
filter(!is.na(birth_date)) %>%
mutate(rookie_age = time_length(ymd(paste0(entry_year, "-09-01")) - birth_date, unit = "days")) %>%
pull(rookie_age) %>%
mean(na.rm = TRUE) %>%
as.numeric()
player_play_type_season_df <- player_play_type_season_df %>%
mutate(birth_date = coalesce(birth_date,
(ymd(paste0(entry_year, "-09-01")) - days(floor(avg_rookie_age)))
),
age = time_length(ymd(paste0(season, "-09-01")) - birth_date, unit = 'years') %>% as.numeric(),
height = coalesce(height, mean(height, na.rm = TRUE))
)
# combine pass and rushing draws for each player -----
# for each player calculate difference from rookie season draw
# Convert the data.frame to a data.table
setDT(player_draws)
# Convert the data.frame to a data.table
setDT(player_draws)
# Perform the operations
player_draws[, b_yoy_diff := b - shift(b), by = .(player_index, .chain, .iteration)]
# Perform the operations
player_draws[, b_yoy_diff := b - shift(b), by = .(player_index, .chain, .iteration)]
gc()
# Perform the operations
player_draws[, b_yoy_diff := b - shift(b), by = .(player_index, .chain, .iteration)]
rm(player_draws_rush)
gc(verbose = TRUE)
# Perform the operations
player_draws[, b_yoy_diff := b - shift(b), by = .(player_index, .chain, .iteration)]
rm(to_model)
rm(to_yrdline_model)
tm(temp)
rm(temp)
gc(verbose = TRUE)
rm(play_quantiles)
rm(params)
rm(params.chain1)
rm(params.chain2)
rm(params.chain1.postburn)
rm(params.chain1.thinned)
rm(params.chain2.thinned)
rm(params.chain2.postburn)
rm(params.chain2)
# Perform the operations
player_draws[, b_yoy_diff := b - shift(b), by = .(player_index, .chain, .iteration)]
rm(list = ls())
gc()
